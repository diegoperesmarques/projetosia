<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Melhorador de Prompt com IA</title>
    <!-- Incluindo Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Incluindo jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Incluindo a biblioteca Marked.js para renderizar Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* Estilo para a fonte Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilo para a barra de rolagem */
        #chat-window::-webkit-scrollbar {
            width: 8px;
        }
        #chat-window::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        #chat-window::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 20px;
            border: 3px solid #f1f5f9;
        }
        /* Estilo para o conteúdo renderizado pelo Marked.js */
        .prose p {
            margin-bottom: 1rem;
        }
        .prose h1, .prose h2, .prose h3 {
            margin-bottom: 0.5rem;
            margin-top: 1.5rem;
        }
        .prose ul, .prose ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }
        .prose li {
            margin-bottom: 0.25rem;
        }
        .prose pre {
            background-color: #f3f4f6;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        .prose code {
            font-family: monospace;
        }
    </style>
</head>
<body class="bg-slate-100 flex flex-col h-screen">

    <!-- Cabeçalho -->
    <header class="bg-white border-b border-slate-200 p-4 shadow-sm">
        <h1 class="text-xl font-semibold text-slate-800">Melhorador de Prompt com IA</h1>
        <p class="text-sm text-slate-500">Digite um prompt e a IA irá aprimorá-lo antes de gerar a resposta final.</p>
    </header>

    <!-- Janela do Chat -->
    <main id="chat-window" class="flex-1 overflow-y-auto p-4 md:p-6 lg:p-8 space-y-6">
        <!-- Mensagem inicial do AI -->
        <div class="flex items-start gap-3">
            <div class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-sm flex-shrink-0">AI</div>
            <div class="bg-white p-4 rounded-lg shadow-sm max-w-2xl prose">
                <p>Olá! Digite uma ideia de prompt e eu irei aprimorá-lo e trazer a resposta.</p>
            </div>
        </div>
    </main>

    <!-- Área de Digitação -->
    <footer class="bg-white border-t border-slate-200 p-4">
        <div class="max-w-3xl mx-auto">
            <div class="relative">
                <textarea id="user-input" class="w-full border-slate-300 rounded-lg p-3 pr-28 resize-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition" placeholder="Digite seu prompt aqui..." rows="1"></textarea>
                <button id="send-button" class="absolute right-3 top-1/2 -translate-y-1/2 bg-blue-600 text-white font-semibold rounded-lg px-5 py-2 hover:bg-blue-700 transition-colors disabled:bg-blue-300 disabled:cursor-not-allowed">
                    Enviar
                </button>
            </div>
        </div>
    </footer>

    <script>
        $(document).ready(function() {
            const userInput = $('#user-input');
            const sendButton = $('#send-button');
            const chatWindow = $('#chat-window');

            // Ajusta a altura do textarea dinamicamente
            userInput.on('input', function () {
                this.style.height = 'auto';
                this.style.height = (this.scrollHeight) + 'px';
            });

            // Função para enviar mensagem com Enter, exceto com Shift
            userInput.on('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Função para enviar mensagem com clique no botão
            sendButton.on('click', sendMessage);

            function sendMessage() {
                const messageText = userInput.val().trim();
                if (messageText === '') return;
                
                // Limpa o chat para uma nova conversa, mantendo a mensagem inicial
                chatWindow.find('.flex.items-start.gap-3:not(:first)').remove();
                chatWindow.find('.flex.items-start.gap-3.justify-end').remove();


                // Exibe a mensagem do usuário na tela
                const userMessageHtml = `
                    <div class="flex items-start gap-3 justify-end">
                        <div class="bg-slate-200 p-4 rounded-lg shadow-sm max-w-2xl">
                            <p>${messageText}</p>
                        </div>
                        <div class="bg-slate-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-sm flex-shrink-0">Você</div>
                    </div>
                `;
                chatWindow.append(userMessageHtml);

                // Limpa o input e reseta a altura
                userInput.val('');
                userInput.css('height', 'auto');
                
                // Desativa o botão de envio e mostra o indicador de "digitando"
                sendButton.prop('disabled', true);
                showTypingIndicator();
                scrollToBottom();

                // Inicia o processo de duas chamadas para a API
                processMessage(messageText);
            }

            function showTypingIndicator() {
                const typingIndicatorHtml = `
                    <div id="typing-indicator" class="flex items-start gap-3">
                        <div class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-sm flex-shrink-0">AI</div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <div class="flex items-center space-x-1">
                                <div class="w-2 h-2 bg-slate-400 rounded-full animate-pulse" style="animation-delay: 0s;"></div>
                                <div class="w-2 h-2 bg-slate-400 rounded-full animate-pulse" style="animation-delay: 0.2s;"></div>
                                <div class="w-2 h-2 bg-slate-400 rounded-full animate-pulse" style="animation-delay: 0.4s;"></div>
                            </div>
                        </div>
                    </div>
                `;
                chatWindow.append(typingIndicatorHtml);
                scrollToBottom();
            }

            async function processMessage(userMessage) {
                // A chave da API será fornecida pelo ambiente, deixe em branco.
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                // Instruções para o engenheiro de prompt
                const promptImproverInstructions = `Aja como um engenheiro sênior de prompt especializado em modelos de linguagem de última geração (LLMs), com mais de 10 anos de experiência otimizando prompts para maximizar clareza, completude, precisão e concisão nas respostas. Você é referência na área de engenharia de prompt e já treinou equipes em empresas de tecnologia, educação e IA aplicada.

Seu objetivo é analisar criticamente o prompt que será fornecido a seguir. Você deve reescrevê-lo de forma mais precisa, detalhada e eficiente, aplicando as melhores práticas da engenharia de prompt. Certifique-se de que a versão aprimorada:

1. Atribua uma identidade clara ao modelo (por exemplo: 'aja como um especialista em...').
2. Defina com clareza o objetivo do usuário.
3. Estruture a tarefa em etapas claras e sequenciais.
4. Utilize um tom profissional, específico e direto, evitando ambiguidades.
5. Aumente a densidade informacional e a clareza do prompt original.
6. Caso necessário, complemente com instruções adicionais que melhorem a profundidade e qualidade da resposta.
7. Finalize o prompt com a instrução: 'Respire fundo e resolva esse problema passo a passo.'
8. Prompt final deve estar no formato markdown dentro de uma estrutura de código de várias linhas, ou seja, estar entre 3 acentos cases.
9. Não mostre mais nada na resposta além do prompt melhorado.

Após aprimorar o prompt, avalie a versão final com uma nota de 0 a 10, justificando o motivo da nota com base nos critérios acima.

Take a deep breath and work on this problem step-by-step.

Abaixo está o prompt que precisa se melhorado:`;

                const firstPrompt = `${promptImproverInstructions}\n\n${userMessage}`;

                try {
                    // --- Primeira Chamada da API: Melhorar o prompt ---
                    const firstPayload = {
                        contents: [{ role: "user", parts: [{ text: firstPrompt }] }],
                        generationConfig: { temperature: 0.5, maxOutputTokens: 2048 },
                    };

                    const firstResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(firstPayload),
                    });

                    if (!firstResponse.ok) {
                        const errorData = await firstResponse.json();
                        throw new Error(`Erro ao melhorar o prompt: ${errorData.error.message}`);
                    }

                    const firstResult = await firstResponse.json();
                    let improvedPrompt = "";
                    if (firstResult.candidates && firstResult.candidates.length > 0 &&
                        firstResult.candidates[0].content && firstResult.candidates[0].content.parts &&
                        firstResult.candidates[0].content.parts.length > 0) {
                        improvedPrompt = firstResult.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error("A resposta da API para melhorar o prompt estava em um formato inesperado ou vazia.");
                    }
                    
                    // --- Segunda Chamada da API: Obter a resposta final ---
                    const secondPayload = {
                        contents: [{ role: "user", parts: [{ text: improvedPrompt }] }],
                        generationConfig: { temperature: 0.7, topK: 1, topP: 1, maxOutputTokens: 2048 },
                    };

                    const secondResponse = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(secondPayload),
                    });

                    if (!secondResponse.ok) {
                        const errorData = await secondResponse.json();
                        throw new Error(`Erro ao gerar a resposta final: ${errorData.error.message}`);
                    }

                    const secondResult = await secondResponse.json();
                    let finalAnswer = "Não foi possível obter uma resposta final.";
                    if (secondResult.candidates && secondResult.candidates.length > 0 &&
                        secondResult.candidates[0].content && secondResult.candidates[0].content.parts &&
                        secondResult.candidates[0].content.parts.length > 0) {
                        finalAnswer = secondResult.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error("A resposta final da API estava em um formato inesperado ou vazia.");
                    }

                    displayAiResponse(finalAnswer);

                } catch (error) {
                    console.error("Erro no processo de mensagem:", error);
                    displayAiResponse(`**Erro:** ${error.message}`);
                } finally {
                    $('#typing-indicator').remove();
                    sendButton.prop('disabled', false);
                    userInput.focus();
                }
            }

            function displayAiResponse(text) {
                $('#typing-indicator').remove();
                
                const formattedText = marked.parse(text);

                const aiMessageHtml = `
                    <div class="flex items-start gap-3">
                        <div class="bg-blue-500 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-sm flex-shrink-0">AI</div>
                        <div class="bg-white p-4 rounded-lg shadow-sm max-w-2xl prose prose-slate">
                            ${formattedText}
                        </div>
                    </div>
                `;
                chatWindow.append(aiMessageHtml);
                scrollToBottom();
            }
            
            function scrollToBottom() {
                chatWindow.scrollTop(chatWindow[0].scrollHeight);
            }
        });
    </script>

</body>
</html>
